/*
 * Copyright 1999-2101 Alibaba Group Holding Ltd.
 *
 * Licensed under the Apache License, Version 2.0 (the "License"); you may not use this file except in compliance with
 * the License. You may obtain a copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on
 * an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the
 * specific language governing permissions and limitations under the License.
 */
package com.itisacat.basic.framework.dao.config.datasource;

import com.alibaba.druid.filter.FilterChain;
import com.alibaba.druid.proxy.jdbc.*;
import com.alibaba.druid.util.JdbcUtils;
import com.alibaba.druid.wall.*;
import com.alibaba.druid.wall.spi.MySqlWallProvider;
import com.alibaba.druid.wall.spi.SQLServerWallProvider;
import com.alibaba.druid.wall.violation.SyntaxErrorViolation;
import com.itisacat.basic.framework.core.util.BeanUtil;
import com.itisacat.basic.framework.dao.route.DataSourceSwitch;
import lombok.extern.slf4j.Slf4j;

import java.sql.SQLException;
import java.util.List;
import java.util.Map;
import java.util.concurrent.ConcurrentHashMap;

@Slf4j
public class WallFilter extends com.alibaba.druid.wall.WallFilter {

    private static final String SQL_INJECTION_VIOLATION = "sql injection violation, ";


    private Map<String, WallProvider> providers = new ConcurrentHashMap<>();


    public WallFilter() {
        super();
    }

    @Override
    public synchronized void init(DataSourceProxy dataSource) {
        super.init(dataSource);
    }

    protected void initProviders() {
        WallConfig mysqlConfig = BeanUtil.copy(super.getConfig(), WallConfig.class);
        mysqlConfig.setDir(MySqlWallProvider.DEFAULT_CONFIG_DIR);
        WallProvider mysqlProvider = new MySqlWallProvider(mysqlConfig);
        providers.put(JdbcUtils.MYSQL, mysqlProvider);

        WallConfig sqlServerConfig = BeanUtil.copy(super.getConfig(), WallConfig.class);
        sqlServerConfig.setDir(SQLServerWallProvider.DEFAULT_CONFIG_DIR);
        WallProvider sqlServerProvider = new SQLServerWallProvider(sqlServerConfig);
        providers.put(JdbcUtils.SQL_SERVER, sqlServerProvider);
    }

    @Override
    public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection, String sql)
            throws SQLException {
        String dbType = DataSourceSwitch.getDataType();
        if (dbType == null) {
            dbType = connection.getDirectDataSource().getDbType();
        }
        WallContext.create(dbType);
        try {
            String sqlChecked = check(sql);
            PreparedStatementProxy stmt = chain.connection_prepareStatement(connection, sqlChecked);
            setSqlStatAttribute(stmt);
            return stmt;
        } finally {
            WallContext.clearContext();
        }
    }

    @Override
    public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection, String sql,
                                                              int autoGeneratedKeys) throws SQLException {
        String dbType = DataSourceSwitch.getDataType();
        if (dbType == null) {
            dbType = connection.getDirectDataSource().getDbType();
        }
        WallContext.create(dbType);
        try {
            String sqlChecked = check(sql);
            PreparedStatementProxy stmt = chain.connection_prepareStatement(connection, sqlChecked, autoGeneratedKeys);
            setSqlStatAttribute(stmt);
            return stmt;
        } finally {
            WallContext.clearContext();
        }
    }

    @Override
    public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection, String sql,
                                                              int resultSetType, int resultSetConcurrency) throws SQLException {
        String dbType = DataSourceSwitch.getDataType();
        if (dbType == null) {
            dbType = connection.getDirectDataSource().getDbType();
        }
        WallContext.create(dbType);
        try {
            String sqlChecked = check(sql);
            PreparedStatementProxy stmt =
                    chain.connection_prepareStatement(connection, sqlChecked, resultSetType, resultSetConcurrency);
            setSqlStatAttribute(stmt);
            return stmt;
        } finally {
            WallContext.clearContext();
        }
    }

    @Override
    public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection, String sql,
                                                              int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        String dbType = DataSourceSwitch.getDataType();
        if (dbType == null) {
            dbType = connection.getDirectDataSource().getDbType();
        }
        WallContext.create(dbType);
        try {
            String sqlChecked = check(sql);
            PreparedStatementProxy stmt = chain.connection_prepareStatement(connection, sqlChecked, resultSetType,
                    resultSetConcurrency, resultSetHoldability);
            setSqlStatAttribute(stmt);
            return stmt;
        } finally {
            WallContext.clearContext();
        }
    }

    @Override
    public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection, String sql,
                                                              int[] columnIndexes) throws SQLException {
        String dbType = DataSourceSwitch.getDataType();
        if (dbType == null) {
            dbType = connection.getDirectDataSource().getDbType();
        }
        WallContext.create(dbType);
        try {
            String sqlChecked = check(sql);
            PreparedStatementProxy stmt = chain.connection_prepareStatement(connection, sqlChecked, columnIndexes);
            setSqlStatAttribute(stmt);
            return stmt;
        } finally {
            WallContext.clearContext();
        }
    }

    @Override
    public PreparedStatementProxy connection_prepareStatement(FilterChain chain, ConnectionProxy connection, String sql,
                                                              String[] columnNames) throws SQLException {
        String dbType = DataSourceSwitch.getDataType();
        if (dbType == null) {
            dbType = connection.getDirectDataSource().getDbType();
        }
        WallContext.create(dbType);
        try {
            String sqlChecked = check(sql);
            PreparedStatementProxy stmt = chain.connection_prepareStatement(connection, sqlChecked, columnNames);
            setSqlStatAttribute(stmt);
            return stmt;
        } finally {
            WallContext.clearContext();
        }
    }

    @Override
    public CallableStatementProxy connection_prepareCall(FilterChain chain, ConnectionProxy connection, String sql)
            throws SQLException {
        String dbType = DataSourceSwitch.getDataType();
        if (dbType == null) {
            dbType = connection.getDirectDataSource().getDbType();
        }
        WallContext.create(dbType);
        try {
            String sqlChecked = check(sql);
            CallableStatementProxy stmt = chain.connection_prepareCall(connection, sqlChecked);
            setSqlStatAttribute(stmt);
            return stmt;
        } finally {
            WallContext.clearContext();
        }
    }

    @Override
    public CallableStatementProxy connection_prepareCall(FilterChain chain, ConnectionProxy connection, String sql,
                                                         int resultSetType, int resultSetConcurrency) throws SQLException {
        String dbType = DataSourceSwitch.getDataType();
        if (dbType == null) {
            dbType = connection.getDirectDataSource().getDbType();
        }
        WallContext.create(dbType);
        try {

            String sqlChecked = check(sql);
            CallableStatementProxy stmt =
                    chain.connection_prepareCall(connection, sqlChecked, resultSetType, resultSetConcurrency);
            setSqlStatAttribute(stmt);
            return stmt;
        } finally {
            WallContext.clearContext();
        }
    }

    @Override
    public CallableStatementProxy connection_prepareCall(FilterChain chain, ConnectionProxy connection, String sql,
                                                         int resultSetType, int resultSetConcurrency, int resultSetHoldability) throws SQLException {
        String dbType = DataSourceSwitch.getDataType();
        if (dbType == null) {
            dbType = connection.getDirectDataSource().getDbType();
        }
        WallContext.create(dbType);
        try {
            String sqlChecked = check(sql);
            CallableStatementProxy stmt = chain.connection_prepareCall(connection, sqlChecked, resultSetType,
                    resultSetConcurrency, resultSetHoldability);
            setSqlStatAttribute(stmt);
            return stmt;
        } finally {
            WallContext.clearContext();
        }
    }

    public String getDbType(StatementProxy statement) {
        return DataSourceSwitch.getDataType();
    }

    public String check(String sql) throws SQLException {
        String jdbctype = DataSourceSwitch.getDataType();
        if (jdbctype == null) {
            jdbctype = JdbcUtils.MYSQL;
        }
        WallCheckResult checkResult = providers.get(jdbctype).check(sql);
        List<Violation> violations = checkResult.getViolations();

        if (!violations.isEmpty()) {
            Violation firstViolation = violations.get(0);
            if (isLogViolation()) {
                log.error(SQL_INJECTION_VIOLATION + firstViolation.getMessage() + " : " + sql);
            }

            if (isThrowException()) {
                if (violations.get(0) instanceof SyntaxErrorViolation) {
                    SyntaxErrorViolation violation = (SyntaxErrorViolation) violations.get(0);
                    throw new SQLException(SQL_INJECTION_VIOLATION + firstViolation.getMessage() + " : " + sql,
                            violation.getException());
                } else {
                    throw new SQLException(SQL_INJECTION_VIOLATION + firstViolation.getMessage() + " : " + sql);
                }
            }
        }

        return checkResult.getSql();
    }

}
